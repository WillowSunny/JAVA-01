# 总结：

堆的参数设置中：

```
1、程序启动的时候就设置好JVM的初始对大小，会比不设置性能更好。

-Xms为应用初始化部署的时候，向操作系统申请多少内存。如果不设置-Xms后，应用只会申请一小部分的内存，当堆内存使用达到峰值，会进行GC而不会重新申请。当应用运行一段时间，堆内存最低水位会逐渐抬高。例如该监控图，一开始最低水位在0.2G，现在到达0.4G。当最低水位一直抬高，应用才会向操作系统申请扩容内存使用。直到到达-Xmx设置阀值。

如果使用VisualVM，可以看到，在不设置Xms的时候，堆的大小一直在缓慢增加，而设置了堆的大小的，从一开始，堆的最大值就固定下来了。
```



```
2、关闭Eden和Survivor区的比例自适应会更好。

如果没有关闭，那Eden去和Survivor区的大小在GC的过程中会不断的变化，这种扩缩容系统级操作也是耗性能的。
```



```
3、堆的大小的设置，并非越高越好

在通过使用不同的堆大小来运行程序，可以看到，最优的设置并不是堆设置成最大的时候。堆大小设置超过了一定程度，反而新能更差。但是这个堆大小的设置和不同的GC有关，有些GC能支持更大的堆，有些在小堆的情况下反而性能最优。

如串行GC，在内存256m的时候，性能会比并行GC更优。
而在内存较大时候，G1的性能会更好点，但是可能是自身机器的原因，在设置堆4g的时候，cms和G1没多大区别
```

吞吐量和响应时间

```
1、在使用不同的JVM参数启动程序，可以发现GC的次数和停顿时间都各不相同，而这些都是影响到系统性能的一个点。
2、有些是GC次数多，但是单次GC停顿时间短，有些是GC次数少，但是停顿时间较长。这里就涉及到了吞吐量和响应时间的两个概念了。

吞吐量=用户线程执行时间/(用户线程执行时间+GC时间)，比如虚拟机总共运行了2秒，但是STW时间达到了0.5秒，那吞吐量=1.5/2=75%

响应时间：虽然GC次数多，但是每次GC的时间都短的话，那就能让程序尽可能的快速响应。这个应该是对应高性能的说法。

这两个指标是从解释上来看，就是矛盾的。只能找到一个较好的平衡点。也就是在高吞吐的前提下尽可能的降低单次GC时间和GC频率。
```

垃圾收集算法

```
1、串行GC是用标记-整理算法的，这个空间利用率比较高，但是性能不好。
2、Parallel并行GC分两部分，年轻代是用复制算法，老年代是用标记整理算法
3、CMS-GC是用标记-清除算法，而且是分有几个阶段，只有在初始标记和最终标记这两个阶段会暂停用户线程，其他时刻都是并行处理的。
```

cms-GC的缺点

```
1、因为是和用户线程并行的，所以他其实是会和服务抢资源的，对CPU资源较为敏感
2、因为是并行的，所以在并发标记和并发清理阶段，是会产生浮动垃圾的，而cms无法被即使回收，只能等待下一次GC的时候进行回收。
3、采用标记-清除算法，所以会产生大量的随便空间，可能导致大对象无法存放而引起OOM，当然一般的都不会出现这个情况，而且可以通过参数设置标记-清除后再做整理。
4、执行过程中会存在不确定性，会导致GC策略退化成串行GC。为什么会出现这个呢，也是因为在并发标记和并发清理的过程中，是和用户线程并行的，很有可能会出现当次GC还没有完成的情况下，又再次触发了FullGC。
```

G1-GC

```
G1GC是真的做到无停顿的并行GC，而且使用的GC算法是复制算法，因此对内存的使用会比CMS高，而且GC的时间是可以根据实际情况做一个设置，G1GC会根据设定的时间，自己决定要选择和进行多少内容的GC，这就会使得G1的GC次数会比较频繁，但对响应性能较好。
```

